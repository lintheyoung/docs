---
title: "Supabase 后端与 Python 模拟器通信指南"
description: "详细介绍 Supabase 后端和 Python 模拟器如何通信，包括 MQTT 频道订阅、连接要求和完整通信流程"
---

# Supabase 后端与 Python 模拟器通信指南

> 详细介绍 Supabase 后端和 Python 模拟器如何通信，包括 MQTT 频道订阅、连接要求和完整通信流程

## 概述

PestGG IoT 系统采用 **AWS IoT Core + Supabase** 双路架构：

- **实时路径**：设备 ⇄ AWS IoT Core (MQTT) ⇄ Web UI - 延迟 < 100ms
- **持久路径**：设备 → AWS IoT Core → Projector Lambda → Supabase - 延迟 1-3秒

### 网关与子设备架构

**重要概念**：

- **网关（Gateway）**：拥有独立 AWS 证书和网络连接的硬件设备，可直接连接 AWS IoT Core
- **子设备（Sub-device）**：无网络连接、无 AWS 证书的设备（如捕鼠器 Trap、振动传感器等），通过本地通信（BLE/Zigbee）连接到网关
- **激活码（Activation Code）**：网关和子设备都有激活码，用于绑定到 Supabase 平台

**通信链路**：

```
子设备（本地通信）→ 网关（AWS 证书）→ AWS IoT Core → Supabase
```

- 子设备不能直接联网，没有网卡和 AWS 证书
- 子设备通过本地通信（如 BLE、Zigbee）连接到网关
- 网关负责转发子设备的数据和命令
- 子设备通过 Named Shadow 区分不同设备（每个子设备有独立的 shadow_name）
- 子设备只需要激活码绑定到用户账号

### 通信架构

```
子设备（Trap/Sensor）
       │
       │ 本地通信（BLE/Zigbee）
       ▼
网关（Gateway）
       │
       ├── MQTT 证书认证 ──► AWS IoT Core
       │                            │
       ├── Shadow Update (reported)  │
       │                            ├── IoT Rule ──► Projector Lambda ──► Supabase
       │                            │
       ◄── Shadow Delta (desired)    │
       │                            │
       └── 转发命令给子设备            │
```

**说明**：
- 网关使用 Classic Shadow 管理自身状态
- 网关使用 Named Shadow 管理每个子设备的状态
- 云端命令通过网关的 Named Shadow Delta 下发
- 网关接收到命令后，通过本地通信转发给对应的子设备

## 1. MQTT 频道订阅

### 1.1 设备需要订阅的频道

Python 模拟器作为网关设备，需要订阅以下 MQTT 主题：

| 主题模式 | 用途 | 订阅时机 |
|---------|------|---------|
| `$aws/things/{thingName}/shadow/name/{shadowName}/update/delta` | 接收云端下发的命令 | MQTT 连接成功后立即订阅 |
| `$aws/things/{thingName}/shadow/name/{shadowName}/update/accepted` | Shadow 更新确认 | 可选，用于确认上报成功 |
| `$aws/things/{thingName}/shadow/name/{shadowName}/get/accepted` | 获取当前 Shadow 状态 | 发送 GET 请求前订阅 |

### 1.2 Python 模拟器订阅代码示例

```python
# virtual_vibration_sensor.py 中的订阅逻辑

def subscribe_to_shadow_deltas(self):
    """订阅所有子设备的 Shadow Delta（接收云端命令）"""
    shadow_name = "vibration-sensor-001"
    thing_name = "IoT-Gateway-000011"

    # 订阅 Delta 主题（接收命令）
    delta_topic = f"$aws/things/{thing_name}/shadow/name/{shadow_name}/update/delta"

    self.mqtt_client.subscribe(
        topic=delta_topic,
        qos=0,  # QoS 0 = AT_MOST_ONCE
        callback=lambda topic, payload: self._on_shadow_delta(topic, payload)
    )

    logger.info(f"✅ Subscribed to delta: {delta_topic}")
```

### 1.3 主题格式说明

#### Classic Shadow（网关自身状态）

网关使用 Classic Shadow 管理自身的连接状态和系统信息。Classic Shadow 用于拥有独立 AWS 证书的设备。

```text
$aws/things/{thingName}/shadow/update
```

#### Named Shadow（子设备状态）

子设备使用 Named Shadow。每一个子设备（如不同的捕鼠器 Trap）都拥有一个独立的 Named Shadow。子设备通过本地通信连接到网关，网关使用 Named Shadow 管理子设备状态。

**关键特点**：
- 子设备无网络连接，无 AWS 证书
- 子设备通过本地通信（BLE/Zigbee）连接到网关
- 网关使用 Named Shadow 管理每个子设备的状态
- 每个子设备有独立的 Named Shadow，通过 shadow_name 区分
- 子设备只需要激活码绑定到用户账号

```text
$aws/things/{thingName}/shadow/name/{shadowName}/update
```

**示例：**
- 网关 Thing: `IoT-Gateway-000011`（拥有证书和网络连接）
- 子设备 Shadow: `vibration-sensor-001`（无证书，通过网关本地通信）
- Delta 主题: `$aws/things/IoT-Gateway-000011/shadow/name/vibration-sensor-001/update/delta`（网关订阅此主题接收子设备命令）

## 2. 连接硬性要求

### 2.1 证书认证

**重要**：只有网关拥有 AWS 证书，子设备没有独立证书。

网关必须使用工厂生产时生成的 X.509 证书连接 AWS IoT Core：

| 配置项 | 说明 | 示例 |
|-------|------|------|
| **证书文件** | 网关证书（绑定到硬件） | `IoT-Gateway-000011.cert.pem` |
| **私钥文件** | 网关私钥（保密） | `IoT-Gateway-000011.private.key` |
| **根 CA** | Amazon 根 CA | `AmazonRootCA1.pem` |
| **IoT Endpoint** | 区域终端节点 | `a1f8xc5wo59rp8-ats.iot.ap-southeast-1.amazonaws.com` |
| **端口** | MQTT over TLS | `8883` |

**证书与激活码的区别**：
- **AWS 证书**：只有网关拥有，用于连接 AWS IoT Core，直接绑定到硬件设备
- **激活码**：网关和子设备都有，用于绑定到 Supabase 平台，关联用户账号

### 2.2 连接参数

```python
# config.py 连接配置

MQTT_ENDPOINT = "a1f8xc5wo59rp8-ats.iot.ap-southeast-1.amazonaws.com"
MQTT_PORT = 8883
MQTT_KEEPALIVE = 30  # Keep-Alive 时间（秒）
MQTT_QOS_TELEMETRY = 0  # 遥测数据 QoS
MQTT_QOS_COMMAND = 0    # 命令响应 QoS
```

### 2.3 设备标识

网关和子设备需要正确配置以下标识：

```python
# config.py 设备标识配置

# 网关配置（拥有 AWS 证书）
GATEWAY_THING = "IoT-Gateway-000011"  # AWS IoT Thing 名称
GATEWAY_DEVICE_ID = "435204e6-21c9-447d-ab6f-888c99b91926"  # Supabase UUID

# 子设备配置（无 AWS 证书，通过网关通信）
# ⚠️ 重要：shadow_name 需要在用户绑定后从数据库查询获取
# 不能使用工厂创建时的初始值，因为绑定时会重新生成
VIRTUAL_DEVICE = {
    'device_id': '09aa8ad8-f23e-4e75-bcbe-332efeb431ce',  # 子设备 UUID
    'shadow_name': 'vibration-sensor-001',  # ⚠️ 示例值，实际需要从数据库查询
    'type': 'vibration_sensor'
}

# 推荐做法：从数据库查询子设备的最新 shadow_name
# SELECT shadow_name, thing_name FROM devices WHERE id = '09aa8ad8-f23e-4e75-bcbe-332efeb431ce';
```

**重要**：
- **网关**：`thing_name` 必须与 AWS IoT 中注册的 Thing 名称一致，拥有对应的证书文件
- **子设备**：`device_id` 必须是 Supabase `devices` 表中的 UUID，通过网关转发通信
- **激活码**：网关和子设备都有激活码，用于用户绑定到 Supabase 平台

**子设备的 thing_name 字段**：
- **工厂创建时**：`null`（子设备没有独立的 AWS IoT Thing）
- **用户绑定后**：继承网关的 `thing_name`（用于标识子设备属于哪个网关）
- **用途**：子设备通过网关的 thing_name 和自己的 shadow_name 组合来唯一标识

**子设备的 shadow_name 字段**：
- **工厂创建时**：生成初始值，格式为 `{type}-{序号}`（如 `vibration-sensor-001`）
- **用户绑定时**：调用数据库函数重新生成唯一的 shadow_name，避免同一网关下冲突
- **用途**：用于区分同一网关下的不同子设备

**子设备的 name 字段**：
- **工厂创建时**：使用初始 shadow_name 作为默认名称
- **用户绑定时**：可以指定自定义名称（custom_name），否则保留默认名称
- **用途**：用于前端显示的友好名称，用户可以修改

**示例**：
- 网关 thing_name: `IoT-Gateway-000011`
- 子设备绑定前 thing_name: `null`
- 子设备绑定后 thing_name: `IoT-Gateway-000011`（继承自网关）
- 子设备 shadow_name: `vibration-sensor-001`（绑定时重新生成）
- 子设备完整标识：`$aws/things/IoT-Gateway-000011/shadow/name/vibration-sensor-001/update`

### 2.4 心跳要求

为保持连接活跃，设备必须：

1. **MQTT Keep-Alive**：设置为 30 秒或更短
2. **定期上报**：至少每 60 秒发送一次遥测数据
3. **Shadow 更新**：即使状态无变化也要定期更新

```python
# 虚拟传感器心跳逻辑
def every_second(self):
    """每秒执行的逻辑"""
    now = time.time()

    # 定时发送遥测数据（10秒间隔）
    if now - self.last_telemetry_time >= self.telemetry_interval:
        self.generate_and_send_telemetry()
        self.last_telemetry_time = now
```

## 3. 完整通信流程

### 3.1 工厂生产阶段

**流程步骤：**

1. **Admin Portal** 调用 `POST /manufacturing-create-devices`
2. **Edge Function** 调用 AWS IoT API 创建 Thing（网关）或子设备记录
3. **AWS IoT Core** 为网关生成设备证书和私钥（子设备不生成证书）
4. **Edge Function** 将设备信息保存到 Supabase 数据库，生成激活码
5. **返回** 设备凭证（网关返回证书和私钥，子设备只返回激活码）

**重要**：
- 网关的 private_key 只在创建时返回，必须安全保存并烧录到硬件
- 子设备不生成 AWS 证书，只生成激活码
- 网关和子设备都有激活码，用于用户绑定

### 3.2 用户绑定阶段

#### 3.2.1 网关绑定流程

**流程步骤：**

1. **User App** 调用 `POST /user-device-bind`，传入网关激活码
2. **Edge Function** 查询激活码并验证未使用
3. **Edge Function** 创建设备所有权记录（device_owners）
4. **Edge Function** 标记激活码已使用
5. **Edge Function** 更新设备状态为 `pending`
6. **返回** 绑定成功，包含 device_id

#### 3.2.2 子设备绑定流程

**重要**：子设备的 shadow_name 在用户绑定时会重新生成

**流程步骤：**

1. **User App** 调用 `POST /user-bind-child-device`，传入网关 ID 和子设备激活码
2. **Edge Function** 查询激活码并验证未使用
3. **Edge Function** 验证子设备状态为 `inactive`（可绑定状态）
4. **Edge Function** 调用数据库函数 `generate_next_shadow_name` 自动生成唯一的 shadow_name
5. **Edge Function** 更新子设备记录：
   - `parent_id`: 网关 UUID
   - `thing_name`: 继承网关的 thing_name
   - `shadow_name`: 新生成的唯一 shadow_name（可能与工厂创建时不同）
   - `name`: 使用 custom_name（如果提供）或保留默认名称
   - `tenant_id`: 继承网关的 tenant_id
   - `status`: 从 `inactive` 变为 `active`
6. **Edge Function** 标记激活码已使用
7. **返回** 绑定成功，包含新的 shadow_name

**注意**：Python 模拟器或实际设备需要在绑定后从数据库查询最新的 shadow_name，不能使用工厂创建时的初始值。

### 3.3 设备状态流转

**网关设备状态**：
1. `registered` - 工厂创建完成
2. `pending` - 用户绑定成功，等待设备首次连接
3. `active` - 设备已连接并正常工作
4. `offline` - 设备离线（超过心跳时间）

**子设备状态**：
1. `registered` - 工厂创建完成
2. `inactive` - 等待用户绑定到网关
3. `active` - 用户绑定成功，设备可用
4. `offline` - 设备离线（通过网关检测）

### 3.4 设备通信阶段

#### 3.4.1 设备启动流程（网关）

1. 网关使用证书连接到 AWS IoT Core
2. 连接成功后，订阅自身的 Classic Shadow 和所有子设备的 Named Shadow Delta 主题
3. 发送 Shadow GET 请求获取当前状态（上线补偿）
4. 检查是否有待执行命令（desired.reqId != reported.lastAckedReqId）
5. 开始定期上报遥测数据（10秒间隔）

#### 3.4.2 命令下发流程（子设备）

**流程步骤：**

1. **User App** 发送 POST 请求到 `/user-device-control`，指定子设备
2. **Edge Function** 查询子设备记录，获取 thing_name（继承自网关）和 shadow_name
3. **Supabase** 更新子设备的 Named Shadow desired 状态
4. **AWS IoT Core** 发布 Delta 消息到网关订阅的主题
5. **网关** 接收 Delta，识别目标子设备
6. **网关** 通过本地通信（如 BLE）将命令转发给子设备
7. **子设备** 执行命令
8. **网关** 更新子设备的 Named Shadow reported 状态（ACK）
9. **Projector Lambda** 将状态同步到 Supabase
10. **User App** 实时接收更新（MQTT/WebSocket）

**关键点**：
- 子设备的 thing_name 是从网关继承的（绑定时设置）
- Edge Function 查询子设备记录时，会同时获取 thing_name 和 shadow_name
- Lambda 使用 thing_name 定位网关，使用 shadow_name 定位子设备
- 完整的 Shadow 路径：`$aws/things/{thing_name}/shadow/name/{shadow_name}/update`
- 子设备无法直接接收云端命令
- 网关负责接收命令并转发给子设备
- 网关代理子设备更新 Shadow 状态

#### 3.4.3 遥测上报流程（子设备）

**流程步骤：**

1. **子设备** 生成遥测数据，通过本地通信发送给网关
2. **网关** 更新子设备的 Named Shadow reported 状态
3. **AWS IoT Core** 发布 Shadow Update documents 事件
4. **IoT Rule** 触发 Projector Lambda
5. **Projector Lambda** 解析主题，存档到 S3，更新 Supabase
6. **Supabase** 更新 telemetry_last 和 device_status 表

**关键点**：
- 子设备通过网关间接上报数据
- 网关使用子设备的 Named Shadow 上报状态
- 云端通过 Named Shadow 区分不同子设备的数据

## 4. Python 模拟器配置

### 4.1 目录结构

```text
PythonDeviceSim/
├── config.py                      # 配置文件
├── aws_iot_client.py              # AWS IoT MQTT 客户端
├── virtual_vibration_sensor.py    # 虚拟传感器实现
├── gui_main.py                    # GUI 界面
├── main.py                        # 启动入口
├── IoT-Gateway-000011.cert.pem    # 设备证书
├── IoT-Gateway-000011.private.key # 设备私钥
└── AmazonRootCA1.pem              # 根 CA
```

### 4.2 核心配置 (config.py)

```python
# AWS IoT 配置
GATEWAY_THING = "IoT-Gateway-000011"
MQTT_ENDPOINT = "a1f8xc5wo59rp8-ats.iot.ap-southeast-1.amazonaws.com"
GATEWAY_DEVICE_ID = "435204e6-21c9-447d-ab6f-888c99b91926"

# 虚拟设备配置
# ⚠️ 重要：shadow_name 需要在用户绑定后从数据库查询获取
# 不能使用工厂创建时的初始值，因为绑定时会重新生成
VIRTUAL_DEVICE = {
    'device_id': '09aa8ad8-f23e-4e75-bcbe-332efeb431ce',
    'shadow_name': 'vibration-sensor-001',  # ⚠️ 示例值，实际需要从数据库查询
    'type': 'vibration_sensor'
}

# 推荐做法：从数据库查询子设备的最新 shadow_name
# SELECT shadow_name, thing_name FROM devices WHERE id = '09aa8ad8-f23e-4e75-bcbe-332efeb431ce';

# MQTT 配置
MQTT_PORT = 8883
MQTT_KEEPALIVE = 30
MQTT_QOS_TELEMETRY = 0  # QoS 0 = AT_MOST_ONCE
MQTT_QOS_COMMAND = 0

# 遥测配置
TELEMETRY_INTERVAL = 10  # 秒
```

### 4.3 启动模拟器

```bash
cd PythonDeviceSim

# GUI 模式
python main.py

# 命令行模式
python -c "from aws_iot_client import AWSIoTClient; from virtual_vibration_sensor import VirtualVibrationSensor; import time; client = AWSIoTClient(); sensor = VirtualVibrationSensor(client); client.connect(); sensor.mqtt_connected(); [sensor.every_second() for _ in range(600) if time.sleep(1) is None]"
```

## 5. 常见问题

### 5.1 连接失败

**问题**：MQTT 连接无法建立

**检查项**：
1. 证书文件路径是否正确
2. Thing Name 是否与 AWS IoT 中注册的一致
3. 网络是否可以访问 IoT Endpoint
4. 证书是否已激活（Active 状态）

```python
# 检查证书
cert_path = "./IoT-Gateway-000011.cert.pem"
key_path = "./IoT-Gateway-000011.private.key"
ca_path = "./AmazonRootCA1.pem"

import os
assert os.path.exists(cert_path), f"证书不存在: {cert_path}"
assert os.path.exists(key_path), f"私钥不存在: {key_path}"
assert os.path.exists(ca_path), f"根CA不存在: {ca_path}"
```

### 5.2 Shadow 更新未生效

**问题**：设备上报状态但前端看不到更新

**检查项**：
1. 是否订阅了正确的 Shadow 主题
2. topic 格式是否正确（Named Shadow 需要 `/shadow/name/{shadowName}/`）
3. payload 格式是否正确（需要 `{"state": {"reported": {...}}}`）

```python
# 正确的 Shadow 更新格式
payload = {
    "state": {
        "reported": {
            "battery": 100,
            "vibration_detected": False,
            "timestamp": int(time.time())
        }
    }
}

topic = f"$aws/things/{thing_name}/shadow/name/{shadow_name}/update"
mqtt_client.publish(topic, json.dumps(payload), qos=0)
```

### 5.3 命令未收到

**问题**：前端发送命令但设备无响应

**检查项**：
1. 是否订阅了 `update/delta` 主题
2. Shadow 的 desired 状态是否正确更新
3. 设备是否在线（检查 last_telemetry_time）

```python
# 检查订阅
delta_topic = f"$aws/things/{thing_name}/shadow/name/{shadow_name}/update/delta"
print(f"Subscribed to: {delta_topic}")

# 在回调中打印收到的命令
def _on_shadow_delta(self, topic, payload):
    delta = json.loads(payload.decode('utf-8'))
    print(f"Received delta: {delta}")
    command = delta.get('state', {})
    req_id = command.get('_reqId')
    print(f"Command: {command}, reqId: {req_id}")
```

### 5.4 ACK 机制

**问题**：命令执行后前端未确认

**解决方案**：
设备在执行命令后必须更新 Shadow，包含 `lastAckedReqId`：

```python
# 执行命令后发送 ACK
def execute_command(self, req_id, command):
    # 执行实际命令逻辑
    if command.get('action') == 'set_threshold':
        self.vibration_threshold = command.get('vibration_threshold')

    # 发送 ACK
    ack_state = {
        'lastAckedReqId': req_id,  # 关键：包含 reqId
        'vibration_threshold': self.vibration_threshold,
        'timestamp': int(time.time())
    }
    self.update_shadow_reported(ack_state)
```

## 6. 数据格式参考

### 6.1 遥测数据格式

```json
{
  "state": {
    "reported": {
      "deviceId": "09aa8ad8-f23e-4e75-bcbe-332efeb431ce",
      "gatewayId": "435204e6-21c9-447d-ab6f-888c99b91926",
      "battery": 95,
      "status": "ok",
      "vibration_detected": false,
      "vibration_level": 2.3,
      "threshold": 5.0,
      "sensitivity": "high",
      "event_count": 3,
      "last_trigger_time": 1702900000,
      "timestamp": 1702900060
    }
  }
}
```

### 6.2 命令格式 (Delta)

```json
{
  "version": 42,
  "timestamp": 1702900100,
  "state": {
    "action": "set_threshold",
    "vibration_threshold": 3.0,
    "sensitivity": "medium",
    "_reqId": "cmd_1702900100_abc123",
    "_priority": "normal"
  }
}
```

### 6.3 ACK 响应格式

```json
{
  "state": {
    "reported": {
      "lastAckedReqId": "cmd_1702900100_abc123",
      "vibration_threshold": 3.0,
      "sensitivity": "medium",
      "timestamp": 1702900105
    }
  }
}
```

## 7. 参考资料

- [PestGG IoT 系统架构](/IOT_SYSTEM_ARCHITECTURE.md) - 完整系统设计文档
- [AWS IoT Device Shadow 文档](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)
- [MQTT QoS 说明](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html)
