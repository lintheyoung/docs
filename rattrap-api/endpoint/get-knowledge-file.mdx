---
title: '获取知识库完整文件'
openapi: 'GET /knowledge-files/{id}'
---

<RequestExample>
```bash cURL
curl https://vwinvkxxheuexvpvzibt.supabase.co/functions/v1/knowledge-files/kb_1a2b3c4d5e6f7g8h \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNzMyNjE4MDAwLCJpYXQiOjE3MzI2MTQ0MDAsImlzcyI6Imh0dHBzOi8vbHJzcHB4YXJoeHZ4Y2Zsb3VnYnAuc3VwYWJhc2UuY28iLCJzdWIiOiJ1c2VyLWlkLWhlcmUifQ.xxx"
```

```bash cURL - 下载文件
curl https://vwinvkxxheuexvpvzibt.supabase.co/functions/v1/knowledge-files/kb_1a2b3c4d5e6f7g8h \
  -H "Authorization: Bearer ${token}" \
  -o downloaded_file.pdf
```

```javascript Node.js
const response = await fetch(
  "https://vwinvkxxheuexvpvzibt.supabase.co/functions/v1/knowledge-files/kb_1a2b3c4d5e6f7g8h",
  {
    method: "GET",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
    },
  }
);

if (response.ok) {
  const blob = await response.blob();
  // 下载文件或显示内容
  const url = URL.createObjectURL(blob);
  window.open(url);
} else {
  const error = await response.json();
  console.error(`访问失败: ${error.error.message}`);
}
```

```python Python
import requests

response = requests.get(
    "https://vwinvkxxheuexvpvzibt.supabase.co/functions/v1/knowledge-files/kb_1a2b3c4d5e6f7g8h",
    headers={
        "Authorization": f"Bearer {access_token}",
    }
)

if response.status_code == 200:
    with open("downloaded_file.pdf", "wb") as f:
        f.write(response.content)
    print("文件下载成功")
else:
    error = response.json()
    print(f"访问失败: {error['error']['message']}")
```
</RequestExample>

<ResponseExample>
```text 成功响应 - 文件内容
HTTP/1.1 200 OK
Content-Type: application/pdf
Content-Disposition: attachment; filename="product_manual.pdf"
Content-Length: 1234567

<文件二进制内容>
```

```json 错误响应 - 未授权
{
  "error": {
    "type": "authentication_error",
    "code": "UNAUTHORIZED",
    "message": "Invalid or missing authentication token",
    "doc_url": "https://docs.rattrap.ai/errors#unauthorized"
  }
}
```

```json 错误响应 - 权限不足
{
  "error": {
    "type": "permission_error",
    "code": "FORBIDDEN",
    "message": "You don't have permission to access this file",
    "details": {
      "access_level": "private",
      "required_role": "admin"
    },
    "doc_url": "https://docs.rattrap.ai/errors#forbidden"
  }
}
```

```json 错误响应 - 文件不存在
{
  "error": {
    "type": "not_found_error",
    "code": "NOT_FOUND",
    "message": "Knowledge file not found",
    "param": "id",
    "doc_url": "https://docs.rattrap.ai/errors#not_found"
  }
}
```
</ResponseExample>

## 使用说明

通过此接口可以下载知识库文件的**完整原始内容**。支持文本、图片、PDF 等各种格式。

<Info>
**与 GET /knowledge-base/{id} 的区别**：
- `GET /knowledge-base/{id}`：返回知识条目的**元数据**（JSON格式）
- `GET /knowledge-files/{id}`：返回知识文件的**完整内容**（原始文件）
</Info>

<CardGroup cols={3}>
  <Card title="完整文件" icon="file-arrow-down">
    返回原始文件的完整内容，非切片
  </Card>
  <Card title="权限验证" icon="shield-check">
    基于 access_level 进行严格的权限验证
  </Card>
  <Card title="切片合并" icon="layer-group">
    自动合并切片，返回完整原始文件
  </Card>
</CardGroup>

<Warning>
**权限要求**：需要登录认证，并根据文件的 `access_level` 进行权限验证。
</Warning>

## 请求参数

### 路径参数

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `id` | string | 是 | 知识库条目 ID 或文件组 ID，格式：`kb_xxx` |

## 访问权限规则

系统会根据知识文件的 `access_level` 字段进行严格的权限验证：

| access_level | 权限要求 | 验证逻辑 | 失败响应 |
|--------------|----------|----------|----------|
| `public` | 任何已登录用户 | 验证 Bearer Token 有效 | 401 UNAUTHORIZED |
| `internal` | 需要登录 | 验证用户已登录且 Token 有效 | 401 UNAUTHORIZED |
| `private` | 需要管理员角色 | 验证用户为 admin 或 owner | 403 FORBIDDEN |

**权限验证流程**：

<Steps>
  <Step title="Bearer Token 验证">
    检查请求 Header 中的 `Authorization: Bearer {token}` 是否有效。
  </Step>
  <Step title="查询文件信息">
    根据 `id` 查询知识库文件，获取 `access_level` 和 `visibility` 字段。
  </Step>
  <Step title="visibility 检查">
    如果 `visibility='private'`，验证用户是否属于该租户。
  </Step>
  <Step title="access_level 验证">
    - `public`：通过第 1 步即可访问
    - `internal`：验证用户已登录
    - `private`：验证用户角色为 admin/owner
  </Step>
  <Step title="返回文件内容">
    验证通过后，返回完整的原始文件内容。
  </Step>
</Steps>

<Warning>
**安全提示**：
- `file_url` 链接不是公开的，包含权限验证
- 即使用户获得了 `file_url`，也必须提供有效的 Bearer Token
- `private` 级别的文件仅管理员可访问，确保敏感文档安全
</Warning>

## 文件切片处理

当知识文件被切片存储时（例如：文件1【第一部分】、文件2【第二部分】），此接口会：

1. **自动识别切片**：根据 `source_file_id` 查找所有切片
2. **合并切片内容**：按顺序合并所有切片的原始内容
3. **返回完整文件**：返回未切片的完整原始文件

**示例流程**：

```
用户请求：GET /knowledge-files/kb_abc123_1
↓
后端处理：
1. 查询 kb_abc123_1，发现 source_file_id = "file_abc123"
2. 查找所有 source_file_id = "file_abc123" 的切片
3. 发现 kb_abc123_1, kb_abc123_2, kb_abc123_3
4. 合并所有切片的原始内容
↓
返回：完整的 product_manual.pdf（5000 tokens）
```

<Info>
**用户体验**：用户无需关心切片逻辑，请求任何切片的 ID 都会返回完整原始文件。
</Info>

## 响应格式

成功响应时，返回原始文件内容（非 JSON 格式）：

| Header | 值 | 说明 |
|--------|---|------|
| `Content-Type` | 文件 MIME 类型 | 例如 `application/pdf`, `image/jpeg`, `text/plain` |
| `Content-Disposition` | `attachment; filename="..."` | 浏览器下载文件时的默认文件名 |
| `Content-Length` | 文件大小（字节） | 文件的总大小 |

**支持的 MIME 类型**：

| 文件类型 | MIME Type |
|----------|-----------|
| PDF | `application/pdf` |
| Word (.docx) | `application/vnd.openxmlformats-officedocument.wordprocessingml.document` |
| 文本 (.txt) | `text/plain; charset=utf-8` |
| Markdown (.md) | `text/markdown; charset=utf-8` |
| JPEG 图片 | `image/jpeg` |
| PNG 图片 | `image/png` |
| WebP 图片 | `image/webp` |

## 错误码

| HTTP 状态码 | 错误代码 | 说明 |
|-----------|---------|------|
| 401 | `UNAUTHORIZED` | 未提供有效的认证 Token |
| 403 | `FORBIDDEN` | 权限不足（需要更高级别的角色） |
| 404 | `NOT_FOUND` | 知识文件不存在或已被删除 |
| 410 | `GONE` | 文件已被删除或不可用 |
| 500 | `INTERNAL_ERROR` | 服务器内部错误 |

## 使用场景

### 场景1：AI 回答中的引用链接

```javascript
// AI 生成回答时包含引用
const answer = {
  text: "RatTrap Pro 的充电口位于底部，详见产品手册...",
  citations: [
    {
      title: "产品使用手册",
      url: "https://[domain]/functions/v1/knowledge-files/kb_abc123",
      // 用户点击链接 → 下载/查看完整 PDF
    }
  ]
};
```

### 场景2：用户主动下载文档

```javascript
// 用户在知识库列表中点击"下载"按钮
async function downloadFile(knowledgeId) {
  const response = await fetch(
    `https://[domain]/functions/v1/knowledge-files/${knowledgeId}`,
    {
      headers: {
        "Authorization": `Bearer ${token}`,
      },
    }
  );

  const blob = await response.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'document.pdf';
  a.click();
}
```

### 场景3：在网页中显示图片

```javascript
// 显示知识库中的图片
<img
  src={`https://[domain]/functions/v1/knowledge-files/${imageId}`}
  onLoad={(e) => {
    e.target.headers = { "Authorization": `Bearer ${token}` };
  }}
/>
```

## 常见问题

<AccordionGroup>
  <Accordion title="为什么需要两个 API（GET /knowledge-base vs GET /knowledge-files）？">
    - `GET /knowledge-base/{id}`：获取**元数据**（JSON格式），用于检索、展示列表、管理
    - `GET /knowledge-files/{id}`：获取**完整文件**（原始格式），用于下载、查看、引用

    两者分离可以提高性能，避免每次查询元数据时都传输大文件。
  </Accordion>

  <Accordion title="切片文件如何处理？">
    后端会自动合并所有切片，返回完整的原始文件。用户无需关心切片逻辑。
  </Accordion>

  <Accordion title="如何判断用户是否有权限访问？">
    在调用此 API 前，可以先调用 `GET /knowledge-base/{id}` 获取 `access_level` 字段：
    - `public`：所有用户可访问
    - `internal`：需要登录
    - `private`：需要管理员

    然后根据当前用户权限决定是否显示下载按钮。
  </Accordion>

  <Accordion title="文件 URL 会过期吗？">
    不会。`file_url` 是长久有效的，但每次访问都需要提供有效的 Bearer Token。
  </Accordion>

  <Accordion title="如何处理大文件？">
    对于超大文件（> 50MB），建议：
    1. 使用流式下载（`response.body` stream）
    2. 显示下载进度条
    3. 考虑分块下载（Range requests）
  </Accordion>

  <Accordion title="图片可以直接在 <img> 标签中使用吗？">
    可以，但需要在请求时携带 Authorization header。对于 public 级别的图片，可以使用 `image_url` 字段（无需认证）。
  </Accordion>
</AccordionGroup>

## 相关资源

- **获取知识库条目**：[/knowledge-base/{id}](/rattrap-api/endpoint/get-knowledge) - 获取知识条目的元数据
- **上传知识库文件**：[/knowledge-upload](/rattrap-api/endpoint/knowledge-upload) - 上传新的知识文件
- **删除知识库文件**：[/knowledge-base/{id}](/rattrap-api/endpoint/delete-knowledge) - 删除知识文件
- **RAG 知识问答系统**：[/rag-qa](/rattrap-api/endpoint/rag-qa) - 查询知识库并生成回答
